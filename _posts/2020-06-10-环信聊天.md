---
layout:     post                    # 使用的布局（不需要改）
title:     环信聊天              # 标题 
subtitle:   代码及效果图 #副标题
date:       2020-06-10           # 时间
author:     李文拓                     # 作者
header-img: img/post-bg-e2e-ux.jpg   #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - Android笔记
---

# 配置
## 1.[环信官网下载SDK带libs文件夹下](http://www.easemob.com/utm_source=baidu-pp)
![](https://cdn.jsdelivr.net/gh/AngleLwt/images/image/347893459719.png)
## 2.然后项目build.gradle加一行代码
```
    /**
     * .son配置 环信IM
     */
    sourceSets {
        main {
            jniLibs.srcDirs = ['libs']
        }
    }
```
**效果如下图所示**
![](https://cdn.jsdelivr.net/gh/AngleLwt/images/image/截屏2020-06-10 下午10.59.52.png)
## 3.在清单文件 AndroidManifest.xml 里加入以下权限，以及注册的 AppKey
- 权限配置
```
    <!-- 环信IM start -->
    <uses-permission android:name="android.permission.VIBRATE" />
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.ACCESS_MOCK_LOCATION" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.GET_TASKS" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />
    <uses-permission android:name="android.permission.READ_PHONE_STATE" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
    <!-- 环信IM end -->
```


```
    /**
     * 获取权限
     */
    private void initPermission() {
        String[] pers = {
                Manifest.permission.RECORD_AUDIO,
                Manifest.permission.CAMERA,
                Manifest.permission.WRITE_EXTERNAL_STORAGE,
                Manifest.permission.ACCESS_FINE_LOCATION,
                Manifest.permission.READ_PHONE_STATE,
                Manifest.permission.ACCESS_COARSE_LOCATION
        };
        ActivityCompat.requestPermissions(this, pers, 100);
    }
    
```


-  配置.        ==设置环信应用的AppKey==
```
    <application
        <!-- 环信IM start -->
        <!-- 设置环信应用的AppKey -->
        <meta-data
            android:name="EASEMOB_APPKEY"
            android:value="#Your AppKey#" />
        <!-- 声明SDK所需的service SDK核心功能-->
        <receiver android:name="com.hyphenate.chat.EMMonitorReceiver">
            <intent-filter>
                <action android:name="android.intent.action.PACKAGE_REMOVED" />
                <data android:scheme="package" />
            </intent-filter>
            <!-- 可选filter -->
            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
                <action android:name="android.intent.action.USER_PRESENT" />
            </intent-filter>
        </receiver>
        <service
            android:name="com.hyphenate.chat.EMChatService"
            android:exported="true" />
        <!-- 声明SDK所需的receiver -->
        <service
            android:name="com.hyphenate.chat.EMJobService"
            android:exported="true"
            android:permission="android.permission.BIND_JOB_SERVICE" />
        <!-- 环信IM start -->
    </application>
```
- ==问题解决== ：用户集成 SDK 后使用 HttpClient 报错

1. Android 6.0及以上版本需要在==module-level/build.gradle==：跟bk在一起
```
android {
    /**
     * 用户集成 SDK 后使用 HttpClient 报错
     * use legacy for android > 6.0
     */
    useLibrary 'org.apache.http.legacy'
   }
```
2. 清单列表
```
    <application
        <!--  用户集成 SDK 后使用 HttpClient 报错  Android 9.0添加：    -->
        <uses-library android:name="org.apache.http.legacy" android:required="false"/>
    </application>        
```
3. Android 9.0上强制使用https的问题
```
        android:usesCleartextTraffic="true"
```


# 实现代码

## 初始化 SDK：要求在 application 的oncreate方法中做初始化，初始化的时候需要传入设置好的 options。
```
    /**
     * 初始化 环信 IMSDK
     * 要求在 application 的oncreate方法中做初始化，初始化的时候需要传入设置好的 options。
     */
    private void initIm() {
        //AppKey: 1127200609181700#weizixundemo
        //Orgname: 1127200609181700
        EMOptions options = new EMOptions();
        // 默认添加好友时，是不需要验证的，改成需要验证
        options.setAcceptInvitationAlways(false);
        // 是否自动将消息附件上传到环信服务器，默认为True是使用环信服务器上传下载，如果设为 false，需要开发者自己处理附件消息的上传和下载
        options.setAutoTransferMessageAttachments(true);
        // 是否自动下载附件类消息的缩略图等，默认为 true 这里和上边这个参数相关联
        options.setAutoDownloadThumbnail(true);
        /**
         * 如果 APP 中有第三方的服务启动
         * 在初始化 SDK（EMClient.getInstance().init(applicationContext, options)）
         * 方法的前面添加以下相关代码
         * 使用 EaseUI 库的就不用理会这个。
         */
        int pid = android.os.Process.myPid();
        String processAppName = getAppName(pid);
        // 如果APP启用了远程的service，此application:onCreate会被调用2次
        // 为了防止环信SDK被初始化2次，加此判断会保证SDK被初始化1次
        // 默认的APP会在以包名为默认的process name下运行，如果查到的process name不是APP的process name就立即返回

        if (processAppName == null || !processAppName.equalsIgnoreCase(this.getPackageName())) {
            // 则此application::onCreate 是被service 调用的，直接返回
            return;
        }
        //....
        //初始化
        EMClient.getInstance().init(this, options);
        //在做打包混淆时，关闭debug模式，避免消耗不必要的资源
        EMClient.getInstance().setDebugMode(true);
    }

    /**
     * 如何获取processAppName请参考以下方法。
     * @param pID
     * @return
     */
    private String getAppName(int pID) {
        String processName = null;
        ActivityManager am = (ActivityManager) this.getSystemService(ACTIVITY_SERVICE);
        List l = am.getRunningAppProcesses();
        Iterator i = l.iterator();
        PackageManager pm = this.getPackageManager();
        while (i.hasNext()) {
            ActivityManager.RunningAppProcessInfo info = (ActivityManager.RunningAppProcessInfo) (i.next());
            try {
                if (info.pid == pID) {
                    processName = info.processName;
                    return processName;
                }
            } catch (Exception e) {
                // Log.d("Process", "Error>> :"+ e.toString());
            }
        }
        return processName;
    }
```
---
## 注册

> 注册模式分两种，开放注册和授权注册。只有开放注册时，才可以客户端注册。
>- .开放注册是为了测试使用，正式环境中不推荐使用该方式注>册环信账号
>- 授权注册的流程应该是您服务器通过环信提供的REST API注册，之后保存到您的服务器或返回给客户端。

```
    /**
     * 环信三方注册
     *
     * @param name
     * @param psw
     */
    private void registerIm(String name, String psw) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    //注册失败会抛出HyphenateException
                    EMClient.getInstance().createAccount(name, psw);//同步方法
                    runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            Toast.makeText(RegisterActivity.this, "注册成功", Toast.LENGTH_SHORT).show();
                            finish();
                        }
                    });
                    finish();
                } catch (HyphenateException e) {
                    runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            Toast.makeText(RegisterActivity.this, "注册失败：" + e.getMessage().toString(), Toast.LENGTH_SHORT).show();
                        }
                    });
                    e.printStackTrace();
                }
            }
        }).start();
    }
```
---
## 登录
common/Constants
```
    //登录的用户名（自定义常量接口）
    String NAME = "name";
```
```
    /**
     * 环信IM三方登陆
     *
     * @param name
     * @param pwd
     */
    private void loginIm(String name, String pwd) {
        if (TextUtils.isEmpty(name)) {
            toast("请输入账号");
        } else if (TextUtils.isEmpty(pwd)) {
            toast("请输入密码");
        } else {
            EMClient.getInstance().login(name, pwd, new EMCallBack() {
                @Override
                public void onSuccess() {
                    EMClient.getInstance().groupManager().loadAllGroups();
                    EMClient.getInstance().chatManager().loadAllConversations();
                    Log.e("TAG", "登录成功！");
                    runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            Toast.makeText(LoginActivity.this, "登录成功", Toast.LENGTH_SHORT).show();
                            //登录成功就保存登录的用户名，为聊天提供聊天方curName
                            SharedPreferencesUtil.setParam(LoginActivity.this, Constants.NAME, name);
                            //跳转到mainactivity
                            goToMainActivity();
                            //关闭页面
                            finish();
                        }
                    });
                }

                @Override
                public void onError(int i, String s) {
                    Log.e("TAG", "登录失败：" + s);
                    runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            Toast.makeText(LoginActivity.this, "登录失败", Toast.LENGTH_SHORT).show();
                        }
                    });
                }

                @Override
                public void onProgress(int i, String s) {

                }
            });
        }
    }
```
---
## 自动登录（LoginActivity）
```
    @Override
    protected void initView() {
        super.initView();
        initPermission();
        //是否登录过
        if (EMClient.getInstance().isLoggedInBefore()) {
            goToMainActivity();
            finish();
        }
    }
```
```
    /**
     * 跳转到主页
     */
    private void goToMainActivity() {
        Intent intent = new Intent(LoginActivity.this, MainActivity.class);
        startActivity(intent);
    }
```
---
## 登出
```
    /**
     * 退出登录
     */
    private void logout() {
        EMClient.getInstance().logout(true, new EMCallBack() {
            @Override
            public void onSuccess() {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        Toast.makeText(MainActivity.this, "登出成功", Toast.LENGTH_SHORT).show();
                        Intent intent = new Intent(MainActivity.this, LoginActivity.class);
                        startActivity(intent);
                        finish();
                    }
                });
            }

            @Override
            public void onError(int i, String s) {
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        Toast.makeText(MainActivity.this, "登出失败：" + s, Toast.LENGTH_SHORT).show();
                    }
                });
            }

            @Override
            public void onProgress(int i, String s) {

            }
        });
    }
```
---
## 单聊


### 主页面
```

public class ChatActivity extends BaseActivity {

    @BindView(R.id.btn_send)
    Button btnSend;
    @BindView(R.id.btn_record)
    Button btnRecord;
    @BindView(R.id.btn_send_audio)
    Button btnSendAudio;
    @BindView(R.id.et_content)
    EditText etContent;
    @BindView(R.id.tv_title)
    TextView tvTitle;
    @BindView(R.id.rv)
    RecyclerView rv;
    private String toName;
    private String curName;
    private ArrayList<EMMessage> list;
    private EMMessageAdapter adapter;
    private EMMessageListener msgListener;
    private String mPath;
    private long mTime;

    @Override
    protected int getLayoutId() {
        return R.layout.activity_chat;
    }

    @OnClick({R.id.btn_send, R.id.btn_record, R.id.btn_send_audio})
    public void onViewClicked(View view) {
        switch (view.getId()) {
            case R.id.btn_send:
                send();
                break;
            case R.id.btn_record:
                record();
                break;
            case R.id.btn_send_audio:
                sendAudio();
                break;
        }
    }

    /**
     * 发送录音
     */
    private void sendAudio() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                //voiceUri为语音文件本地资源标志符，length为录音时间(秒)
                EMMessage message = EMMessage.createVoiceSendMessage(mPath, (int) mTime, toName);
                EMClient.getInstance().chatManager().sendMessage(message);
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        //录音添加到消息中
                        list.add(message);
                        //刷新适配器
                        adapter.notifyDataSetChanged();
                    }
                });
            }
        }).start();
    }

    /**
     * 录音
     */
    private void record() {
        //是否正在录音
        boolean isRecording = AudioUtil.isRecording;
        if (isRecording) {
            btnRecord.setText("开始录音");
            AudioUtil.stopRecord();
        } else {
            btnRecord.setText("停止录音");
            AudioUtil.startRecord(new AudioUtil.ResultCallBack() {
                @Override
                public void onSuccess(String path, long time) {
                    mPath = path;
                    mTime = time;
                }

                @Override
                public void onFail(String msg) {
                    Log.e("TAG", msg);
                }
            });
        }
    }

    /**
     * 发送消息
     */
    private void send() {
        String content = etContent.getText().toString();

        if (content.isEmpty()) {
            Toast.makeText(ChatActivity.this, "请输入消息", Toast.LENGTH_SHORT).show();
            return;
        }
        new Thread(new Runnable() {
            @Override
            public void run() {
                //创建一条文本消息，content为消息文字内容，toChatUsername为对方用户或者群聊的id，后文皆是如此
                EMMessage message = EMMessage.createTxtSendMessage(content, toName);
                //发送消息
                EMClient.getInstance().chatManager().sendMessage(message);
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        list.add(message);
                        adapter.notifyDataSetChanged();
                        etContent.setText("");
                    }
                });
            }
        }).start();
    }

    @Override
    protected void initView() {
        super.initView();
        //获取到的name是被接收信息的user  ：  toName  问题：发送消息的位置不对
        toName = getIntent().getStringExtra(Constants.NAME);
        curName = (String) SharedPreferencesUtil.getParam(this, Constants.NAME, "a");
        //设置聊天标题
        tvTitle.setText(curName + "正在和" + toName + "聊天中...");
        //EMMessage 发送的消息
        list = new ArrayList<>();
        rv.setLayoutManager(new LinearLayoutManager(this));
        adapter = new EMMessageAdapter(list, this, toName, curName);
        rv.setAdapter(adapter);
        //点击列表的语言消息播放语言
        adapter.setOnItemClick(new EMMessageAdapter.OnItemClick() {
            @Override
            public void onItemClick(String localUrl) {
                playAudio(localUrl);
            }
        });
    }

    /**
     * 历史消息
     */
    @Override
    protected void initListener() {
        super.initListener();
        //通过注册消息监听来接收消息。
        initReceiver();
        //保存历史消息
        initHistory();
    }

    /**
     * 播放语言
     * @param localUrl
     */
    private void playAudio(String localUrl) {
        MediaPlayer mediaPlayer = new MediaPlayer();
        try {
            boolean playing = mediaPlayer.isPlaying();
            if (playing) {
                mediaPlayer.pause();
            }
            if (TextUtils.isEmpty(localUrl)) {
                return;
            }
            mediaPlayer.setDataSource(localUrl);
            mediaPlayer.prepare();
            mediaPlayer.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void initHistory() {
        EMConversation conversation = EMClient.getInstance().chatManager().getConversation(toName);
        //获取此会话的所有消息
        if (conversation == null) {
            return;
        }
        List<EMMessage> messages = conversation.getAllMessages();
        list.addAll(messages);
        adapter.notifyDataSetChanged();
    }

    private void initReceiver() {
        msgListener = new EMMessageListener() {
            @Override
            public void onMessageReceived(List<EMMessage> messages) {
                //收到消息
                list.addAll(messages);
                adapter.notifyDataSetChanged();
            }

            @Override
            public void onCmdMessageReceived(List<EMMessage> messages) {
                //收到透传消息
            }

            @Override
            public void onMessageRead(List<EMMessage> messages) {
                //收到已读回执
            }

            @Override
            public void onMessageDelivered(List<EMMessage> message) {
                //收到已送达回执
            }

            @Override
            public void onMessageRecalled(List<EMMessage> messages) {
                //消息被撤回
            }

            @Override
            public void onMessageChanged(EMMessage message, Object change) {
                //消息状态变动
            }
        };

        EMClient.getInstance().chatManager().addMessageListener(msgListener);
    }

    /**
     * 记得在不需要的时候移除listener，如在activity的onDestroy()时
     */
    @Override
    protected void onDestroy() {
        super.onDestroy();
        EMClient.getInstance().chatManager().removeMessageListener(msgListener);
    }
}
```
### 适配器
##### 会话适配器
```


public class EMMessageAdapter extends RecyclerView.Adapter {
//    设置消息集合
    private ArrayList<EMMessage> msgs;
    private Context context;
//    获得当前用户名
    private String curName;
    private String name;
    private OnItemClick onItemClick;

    public void setOnItemClick(OnItemClick onItemClick) {
        this.onItemClick = onItemClick;
    }

    public EMMessageAdapter(ArrayList<EMMessage> msgs, Context context, String curName, String name) {
        this.msgs = msgs;
        this.context = context;
        this.curName = curName;
        this.name = name;
    }

    @Override
    public int getItemViewType(int position) {
        EMMessage emMessage = msgs.get(position);
        String from = emMessage.getFrom();
//     如果是当前用户名
        if (from.equals(curName)) {
            return 0;
        } else {
            return 1;
        }
    }

    @NonNull
    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        switch (viewType) {
            case 0:
                View myView = LayoutInflater.from(context).inflate(R.layout.item_right, parent, false);
                return new MyEmMessageViewHolder(myView);
            case 1:
                View otherView = LayoutInflater.from(context).inflate(R.layout.item_left, parent, false);
                return new OtherEmMessageViewHolder(otherView);

        }
        return null;
    }

    @Override
    public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) {
        EMMessage emMessage = msgs.get(position);
        switch (getItemViewType(position)) {
            case 0:
                MyEmMessageViewHolder myEmMessageViewHolder = (MyEmMessageViewHolder) holder;
                myEmMessageViewHolder.tvMyMessage.setText(emMessage.getBody().toString());
                myEmMessageViewHolder.tvMyName.setText(curName);
                break;
            case 1:
                OtherEmMessageViewHolder otherEmMessageViewHolder = (OtherEmMessageViewHolder) holder;
                otherEmMessageViewHolder.tvOtherName.setText(emMessage.getFrom());
                otherEmMessageViewHolder.tvOtherMessage.setText(emMessage.getBody().toString());
                break;

        }
        holder.itemView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                EMMessageBody body = emMessage.getBody();
                //Log.d(TAG, "onClick: "+body.toStrin g());
                String s = body.toString();
                String localUrl = "";
                String[] split = s.split(",");
                for (int i = 0; i < split.length; i++) {
                    String s1 = split[i];
                    String[] split1 = s1.split(":");
                    for (int j = 0; j < split1.length; j++) {
                        String s2 = split1[j];
                        Log.d(TAG, "onClick: " + s2);
                        if (s2.startsWith("/storage/emulated")) {
                            localUrl = s2;
                            break;
                        }
                    }
                }

                Log.d(TAG, "localUrl: " + localUrl);
                if (onItemClick != null) {
                    onItemClick.itemClick(localUrl);
                }
            }
        });
    }

    @Override
    public int getItemCount() {
        return msgs.size();
    }

    static
    class MyEmMessageViewHolder extends RecyclerView.ViewHolder {
        @BindView(R.id.tv_my_name)
        TextView tvMyName;
        @BindView(R.id.tv_my_message)
        TextView tvMyMessage;

        MyEmMessageViewHolder(View view) {
            super(view);
            ButterKnife.bind(this, view);
        }
    }

    static
    class OtherEmMessageViewHolder extends RecyclerView.ViewHolder {
        @BindView(R.id.tv_other_name)
        TextView tvOtherName;
        @BindView(R.id.tv_other_message)
        TextView tvOtherMessage;

        OtherEmMessageViewHolder(View view) {
            super(view);
            ButterKnife.bind(this, view);
        }
    }

    public interface OnItemClick {
        void itemClick(String localUrl);
    }
}
```  

#### 用户适配器(用户列表Fragment)

```

public class UserAdapter extends RecyclerView.Adapter {
//    设置User集合
    private ArrayList<String> users;
    private Context context;
    private OnItemClick onItemClick;

    public void setOnItemClick(OnItemClick onItemClick) {
        this.onItemClick = onItemClick;
    }

    public UserAdapter(ArrayList<String> users, Context context) {
        this.users = users;
        this.context = context;
    }

    @NonNull
    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(context).inflate(R.layout.item_users, parent, false);
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) {
        ViewHolder viewHolder = (ViewHolder) holder;
        String name = users.get(position);
        viewHolder.tvItemUsers.setText(name);
        viewHolder.itemView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                if (onItemClick != null) {
                    onItemClick.clickUser(position, name);
                }
            }
        });

    }

    @Override
    public int getItemCount() {
        return users.size();
    }

    static
    class ViewHolder extends RecyclerView.ViewHolder {
        @BindView(R.id.iv_item_users)
        ImageView ivItemUsers;
        @BindView(R.id.tv_item_users)
        TextView tvItemUsers;

        ViewHolder(View view) {
            super(view);
            ButterKnife.bind(this, view);
        }
    }

    public interface OnItemClick {
        void clickUser(int position, String name);
    }
}

``` 
### 工具类 
#### AudioUtil 
```

public class AudioUtil {
    /**
     * 采样率，现在能够保证在所有设备上使用的采样率是44100Hz, 但是其他的采样率（22050, 16000, 11025）在一些设备上也可以使用。
     */
    public static final int SAMPLE_RATE_INHZ = 44100;

    /**
     * 声道数。CHANNEL_IN_MONO and CHANNEL_IN_STEREO. 其中CHANNEL_IN_MONO是可以保证在所有设备能够使用的。
     */
    public static final int CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_MONO;
    /**
     * 返回的音频数据的格式。 ENCODING_PCM_8BIT, ENCODING_PCM_16BIT, and ENCODING_PCM_FLOAT.
     */
    public static final int AUDIO_FORMAT = AudioFormat.ENCODING_PCM_16BIT;

    private static final String TAG = "AudioUtil";
    private static AudioRecord audioRecord;
    private static String mPath = Environment.getExternalStorageDirectory().getAbsolutePath()
            + "/录音/";
    public static boolean isRecording;
    private static long mAudioName;
    private static long sEndTime;
    private static long sDuration;

    /**
     * 开始录音
     *
     * @param callBack
     */
    public static void startRecord(final ResultCallBack callBack) {
        //当前时间的毫秒
        mAudioName = System.currentTimeMillis();
        final int minBufferSize = AudioRecord.getMinBufferSize(SAMPLE_RATE_INHZ, CHANNEL_CONFIG, AUDIO_FORMAT);
        audioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC, SAMPLE_RATE_INHZ,
                CHANNEL_CONFIG, AUDIO_FORMAT, minBufferSize);

        final byte data[] = new byte[minBufferSize];
        final File file = new File(mPath, mAudioName + ".pcm");
        if (!file.mkdirs()) {
            Log.e(TAG, "Directory not created");
        }
        if (file.exists()) {
            file.delete();
        }
        //录音
        audioRecord.startRecording();
        isRecording = true;

        //将录音写入本地文件
        new Thread(new Runnable() {
            @Override
            public void run() {
                FileOutputStream os = null;
                try {
                    os = new FileOutputStream(file);
                } catch (FileNotFoundException e) {
                    e.printStackTrace();
                }

                if (null != os) {
                    while (isRecording) {
                        int read = audioRecord.read(data, 0, minBufferSize);
                        // 如果读取音频数据没有出现错误，就将数据写入到文件
                        if (AudioRecord.ERROR_INVALID_OPERATION != read) {
                            try {
                                os.write(data);
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                    try {
                        Log.i(TAG, "run: close file output stream !");
                        os.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                        callBack.onFail(e.toString());
                    }

                    sEndTime = System.currentTimeMillis();
                    sDuration = sEndTime - mAudioName;
                    //将PCM格式的录音转换为wav的,方便播放
                    PcmToWavUtil pcmToWavUtil = new PcmToWavUtil(SAMPLE_RATE_INHZ, CHANNEL_CONFIG, AUDIO_FORMAT);
                    File pcmFile = new File(mPath, mAudioName + ".pcm");
                    File wavFile = new File(mPath, mAudioName + ".wav");
                    if (!wavFile.mkdirs()) {
                        Log.e(TAG, "wavFile Directory not created");
                    }
                    if (wavFile.exists()) {
                        wavFile.delete();
                    }
                    pcmToWavUtil.pcmToWav(pcmFile.getAbsolutePath(), wavFile.getAbsolutePath());
                    //将结果回调给调用者
                    callBack.onSuccess(wavFile.getAbsolutePath(), sDuration);
                }
            }
        }).start();
    }

    /**
     * 停止录音
     */
    public static void stopRecord() {
        isRecording = false;
        // 释放资源
        if (null != audioRecord) {
            audioRecord.stop();
            audioRecord.release();
            audioRecord = null;
            //recordingThread = null;
        }
    }

    /**
     * 将pcm音频文件转换为wav音频文件
     */
    public static class PcmToWavUtil {

        /**
         * 缓存的音频大小
         */
        private static int mBufferSize;
        /**
         * 采样率
         */
        private static int mSampleRate;
        /**
         * 声道数
         */
        private static int mChannel;


        /**
         * @param sampleRate sample rate、采样率
         * @param channel    channel、声道
         * @param encoding   Audio data format、音频格式
         */
        PcmToWavUtil(int sampleRate, int channel, int encoding) {
            this.mSampleRate = sampleRate;
            this.mChannel = channel;
            this.mBufferSize = AudioRecord.getMinBufferSize(mSampleRate, mChannel, encoding);
        }


        /**
         * pcm文件转wav文件
         *
         * @param inFilename  源文件路径
         * @param outFilename 目标文件路径
         */
        public static void pcmToWav(String inFilename, String outFilename) {
            FileInputStream in;
            FileOutputStream out;
            long totalAudioLen;
            long totalDataLen;
            long longSampleRate = mSampleRate;
            int channels = mChannel == AudioFormat.CHANNEL_IN_MONO ? 1 : 2;
            long byteRate = 16 * mSampleRate * channels / 8;
            byte[] data = new byte[mBufferSize];
            try {
                in = new FileInputStream(inFilename);
                out = new FileOutputStream(outFilename);
                totalAudioLen = in.getChannel().size();
                totalDataLen = totalAudioLen + 36;

                writeWaveFileHeader(out, totalAudioLen, totalDataLen,
                        longSampleRate, channels, byteRate);
                while (in.read(data) != -1) {
                    out.write(data);
                }
                in.close();
                out.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }


        /**
         * 加入wav文件头
         */
        private static void writeWaveFileHeader(FileOutputStream out, long totalAudioLen,
                                                long totalDataLen, long longSampleRate, int channels, long byteRate)
                throws IOException {
            byte[] header = new byte[44];
            // RIFF/WAVE header
            header[0] = 'R';
            header[1] = 'I';
            header[2] = 'F';
            header[3] = 'F';
            header[4] = (byte) (totalDataLen & 0xff);
            header[5] = (byte) ((totalDataLen >> 8) & 0xff);
            header[6] = (byte) ((totalDataLen >> 16) & 0xff);
            header[7] = (byte) ((totalDataLen >> 24) & 0xff);
            //WAVE
            header[8] = 'W';
            header[9] = 'A';
            header[10] = 'V';
            header[11] = 'E';
            // 'fmt ' chunk
            header[12] = 'f';
            header[13] = 'm';
            header[14] = 't';
            header[15] = ' ';
            // 4 bytes: size of 'fmt ' chunk
            header[16] = 16;
            header[17] = 0;
            header[18] = 0;
            header[19] = 0;
            // format = 1
            header[20] = 1;
            header[21] = 0;
            header[22] = (byte) channels;
            header[23] = 0;
            header[24] = (byte) (longSampleRate & 0xff);
            header[25] = (byte) ((longSampleRate >> 8) & 0xff);
            header[26] = (byte) ((longSampleRate >> 16) & 0xff);
            header[27] = (byte) ((longSampleRate >> 24) & 0xff);
            header[28] = (byte) (byteRate & 0xff);
            header[29] = (byte) ((byteRate >> 8) & 0xff);
            header[30] = (byte) ((byteRate >> 16) & 0xff);
            header[31] = (byte) ((byteRate >> 24) & 0xff);
            // block align
            header[32] = (byte) (2 * 16 / 8);
            header[33] = 0;
            // bits per sample
            header[34] = 16;
            header[35] = 0;
            //data
            header[36] = 'd';
            header[37] = 'a';
            header[38] = 't';
            header[39] = 'a';
            header[40] = (byte) (totalAudioLen & 0xff);
            header[41] = (byte) ((totalAudioLen >> 8) & 0xff);
            header[42] = (byte) ((totalAudioLen >> 16) & 0xff);
            header[43] = (byte) ((totalAudioLen >> 24) & 0xff);
            out.write(header, 0, 44);
        }
    }

    public interface ResultCallBack {
        void onSuccess(String path, long time);

        void onFail(String msg);
    }


}
``` 
#### SharedPreferencesUtils 
```

public class SharedPreferencesUtils {
    /**
     * 保存在手机里面的文件名
     */
    private static final String FILE_NAME = "share_date";


    /**
     * 保存数据的方法，我们需要拿到保存数据的具体类型，然后根据类型调用不同的保存方法
     * @param context
     * @param key
     * @param object
     */
    public static void setParam(Context context , String key, Object object){

        String type = object.getClass().getSimpleName();
        SharedPreferences sp = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);
        SharedPreferences.Editor editor = sp.edit();

        if("String".equals(type)){
            editor.putString(key, (String)object);
        }
        else if("Integer".equals(type)){
            editor.putInt(key, (Integer)object);
        }
        else if("Boolean".equals(type)){
            editor.putBoolean(key, (Boolean)object);
        }
        else if("Float".equals(type)){
            editor.putFloat(key, (Float)object);
        }
        else if("Long".equals(type)){
            editor.putLong(key, (Long)object);
        }

        editor.commit();
    }


    /**
     * 得到保存数据的方法，我们根据默认值得到保存的数据的具体类型，然后调用相对于的方法获取值
     * @param context
     * @param key
     * @param defaultObject
     * @return
     */
    public static Object getParam(Context context , String key, Object defaultObject){
        String type = defaultObject.getClass().getSimpleName();
        SharedPreferences sp = context.getSharedPreferences(FILE_NAME, Context.MODE_PRIVATE);

        if("String".equals(type)){
            return sp.getString(key, (String)defaultObject);
        }
        else if("Integer".equals(type)){
            return sp.getInt(key, (Integer)defaultObject);
        }
        else if("Boolean".equals(type)){
            return sp.getBoolean(key, (Boolean)defaultObject);
        }
        else if("Float".equals(type)){
            return sp.getFloat(key, (Float)defaultObject);
        }
        else if("Long".equals(type)){
            return sp.getLong(key, (Long)defaultObject);
        }

        return null;
    }
}

```